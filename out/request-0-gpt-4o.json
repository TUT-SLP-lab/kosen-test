{
  "model": "gpt-4o",
  "output": "以下が、指定された条件を満たすC言語での二分探索のプログラムです：\n\n```c\n#include <stdio.h>\n\nint binary_search(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return mid;\n        }\n\n        if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int A[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int B;\n    scanf(\"%d\", &B);\n\n    int result = binary_search(A, N, B);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}\n```\n\n### プログラムの説明\n\n1. **binary_search関数**:\n   - この関数は、引数としてソート済み配列`arr`、配列の長さ`n`、および探索する値`target`をとります。\n   - 左端のインデックス`left`と右端のインデックス`right`を初期化します。\n   - ループ内で中央のインデックス`mid`を計算し、`arr[mid]`と`target`を比較します。\n     - 一致する場合、インデックス`mid`を返します。\n     - `arr[mid]`が`target`より小さい場合、探索範囲を右側に変更します。\n     - `arr[mid]`が`target`より大きい場合、探索範囲を左側に変更します。\n   - 探索範囲がなくなると、-1を返します（見つからない場合）。\n\n2. **main関数**:\n   - 標準入力から配列の長さ`N`を読み取ります。\n   - 配列`A`の要素を順に読み取ります。\n   - 探索する値`B`を読み取ります。\n   - `binary_search`関数を呼び出して結果を出力します。\n\nこれにより、標準入力からの値に基づいて二分探索を実行し、結果を標準出力に出力します。",
  "input": "二分探索のプログラムをC言語で書いてください。標準入力からソート済みの配列Aの長さNと要素A_1...A_N、探索する値Bが与えられます。BがAに存在する場合はインデックス、存在しない場合は-1を標準出力に出力してください。回答以外は標準出力には出力してはいけません。"
}